"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEntryPoints = void 0;
const devkit_1 = require("@nx/devkit");
const fs = require("fs");
const path = require("path");
const glob = require("fast-glob");
function getEntryPoints(projectName, context, options = {}) {
    const entryPoints = options.initialEntryPoints
        ? new Set(options.initialEntryPoints)
        : new Set();
    const seenProjects = new Set();
    const findEntryPoints = (projectName, tsConfigFileName) => {
        var _a, _b, _c, _d;
        if (seenProjects.has(projectName))
            return;
        seenProjects.add(projectName);
        const project = (_a = context.projectGraph) === null || _a === void 0 ? void 0 : _a.nodes[projectName];
        if (!project)
            return;
        // Known files we generate from our generators. Only one of these should be used to build the project.
        const tsconfigCandidates = [
            'tsconfig.app.json',
            'tsconfig.lib.json',
            'tsconfig.json',
        ];
        if (tsConfigFileName)
            tsconfigCandidates.unshift(tsConfigFileName);
        const foundTsConfig = tsconfigCandidates.find((f) => {
            try {
                return fs.statSync(path.join(project.data.root, f)).isFile();
            }
            catch (_a) {
                return false;
            }
        });
        // Workspace projects may not be a TS project, so skip reading source files if tsconfig is not found.
        if (foundTsConfig) {
            const tsconfig = (0, devkit_1.readJsonFile)(path.join(project.data.root, foundTsConfig));
            const projectFiles = glob
                .sync((_b = tsconfig.include) !== null && _b !== void 0 ? _b : [], {
                cwd: project.data.root,
                ignore: (_c = tsconfig.exclude) !== null && _c !== void 0 ? _c : [],
            })
                .map((f) => path.join(project.data.root, f));
            projectFiles.forEach((f) => entryPoints.add(f));
            (_d = options === null || options === void 0 ? void 0 : options.onProjectFilesMatched) === null || _d === void 0 ? void 0 : _d.call(options, projectName, projectFiles);
        }
        if (options.recursive) {
            const deps = context.projectGraph.dependencies[projectName];
            deps.forEach((dep) => {
                if (context.projectGraph.nodes[dep.target]) {
                    findEntryPoints(dep.target);
                }
            });
        }
    };
    findEntryPoints(projectName, options.initialTsConfigFileName);
    return Array.from(entryPoints);
}
exports.getEntryPoints = getEntryPoints;
