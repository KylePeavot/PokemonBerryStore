"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.esbuildExecutor = void 0;
const tslib_1 = require("tslib");
require("dotenv/config");
const chalk = require("chalk");
const devkit_1 = require("@nx/devkit");
const js_1 = require("@nx/js");
const esbuild = require("esbuild");
const normalize_1 = require("./lib/normalize");
const fs_extra_1 = require("fs-extra");
const async_iterable_1 = require("@nx/devkit/src/utils/async-iterable");
const build_esbuild_options_1 = require("./lib/build-esbuild-options");
const get_extra_dependencies_1 = require("./lib/get-extra-dependencies");
const path_1 = require("path");
const BUILD_WATCH_FAILED = `[ ${chalk.red('watch')} ] build finished with errors (see above), watching for changes...`;
const BUILD_WATCH_SUCCEEDED = `[ ${chalk.green('watch')} ] build succeeded, watching for changes...`;
function esbuildExecutor(_options, context) {
    var _a, _b;
    var _c;
    return tslib_1.__asyncGenerator(this, arguments, function* esbuildExecutor_1() {
        (_a = (_c = process.env).NODE_ENV) !== null && _a !== void 0 ? _a : (_c.NODE_ENV = (_b = context.configurationName) !== null && _b !== void 0 ? _b : 'production');
        const options = (0, normalize_1.normalizeOptions)(_options, context);
        if (options.deleteOutputPath)
            (0, fs_extra_1.removeSync)(options.outputPath);
        const assetsResult = yield tslib_1.__await((0, js_1.copyAssets)(options, context));
        const externalDependencies = options.external.reduce((acc, name) => {
            const externalNode = context.projectGraph.externalNodes[`npm:${name}`];
            if (externalNode) {
                acc.push({
                    name,
                    outputs: [],
                    node: externalNode,
                });
            }
            return acc;
        }, []);
        if (!options.thirdParty) {
            const thirdPartyDependencies = (0, get_extra_dependencies_1.getExtraDependencies)(context.projectName, context.projectGraph);
            for (const tpd of thirdPartyDependencies) {
                options.external.push(tpd.node.data.packageName);
                externalDependencies.push(tpd);
            }
        }
        let packageJsonResult;
        if (options.generatePackageJson) {
            if (context.projectGraph.nodes[context.projectName].type !== 'app') {
                devkit_1.logger.warn((0, devkit_1.stripIndents) `The project ${context.projectName} is using the 'generatePackageJson' option which is deprecated for library projects. It should only be used for applications.
        For libraries, configure the project to use the '@nx/dependency-checks' ESLint rule instead (https://nx.dev/packages/eslint-plugin/documents/dependency-checks).`);
            }
            const cpjOptions = Object.assign(Object.assign({}, options), { 
                // TODO(jack): make types generate with esbuild
                skipTypings: true, outputFileExtensionForCjs: (0, build_esbuild_options_1.getOutExtension)('cjs', options), excludeLibsInPackageJson: !options.thirdParty, updateBuildableProjectDepsInPackageJson: externalDependencies.length > 0 });
            // If we're bundling third-party packages, then any extra deps from external should be the only deps in package.json
            if (options.thirdParty && externalDependencies.length > 0) {
                cpjOptions.overrideDependencies = externalDependencies;
            }
            else {
                cpjOptions.extraDependencies = externalDependencies;
            }
            packageJsonResult = yield tslib_1.__await((0, js_1.copyPackageJson)(cpjOptions, context));
        }
        if (options.watch) {
            return yield tslib_1.__await(yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues((0, async_iterable_1.createAsyncIterable)(({ next, done }) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                let hasTypeErrors = false;
                const disposeFns = yield Promise.all(options.format.map((format, idx) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const esbuildOptions = (0, build_esbuild_options_1.buildEsbuildOptions)(format, options, context);
                    const ctx = yield esbuild.context(Object.assign(Object.assign({}, esbuildOptions), { plugins: [
                            // Only emit info on one of the watch processes.
                            idx === 0
                                ? {
                                    name: 'nx-watch-plugin',
                                    setup(build) {
                                        build.onEnd((result) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                                            if (!options.skipTypeCheck) {
                                                const { errors } = yield runTypeCheck(options, context);
                                                hasTypeErrors = errors.length > 0;
                                            }
                                            const success = result.errors.length === 0 && !hasTypeErrors;
                                            if (!success) {
                                                devkit_1.logger.info(BUILD_WATCH_FAILED);
                                            }
                                            else {
                                                devkit_1.logger.info(BUILD_WATCH_SUCCEEDED);
                                            }
                                            next({
                                                success,
                                                // Need to call getOutfile directly in the case of bundle=false and outfile is not set for esbuild.
                                                outfile: (0, path_1.join)(context.root, (0, build_esbuild_options_1.getOutfile)(format, options, context)),
                                            });
                                        }));
                                    },
                                }
                                : null,
                        ].filter(Boolean) }));
                    yield ctx.watch();
                    return () => ctx.dispose();
                })));
                registerCleanupCallback(() => {
                    assetsResult === null || assetsResult === void 0 ? void 0 : assetsResult.stop();
                    packageJsonResult === null || packageJsonResult === void 0 ? void 0 : packageJsonResult.stop();
                    disposeFns.forEach((fn) => fn());
                    done(); // return from async iterable
                });
            }))))));
        }
        else {
            // Run type-checks first and bail if they don't pass.
            if (!options.skipTypeCheck) {
                const { errors } = yield tslib_1.__await(runTypeCheck(options, context));
                if (errors.length > 0) {
                    yield yield tslib_1.__await({ success: false });
                    return yield tslib_1.__await(void 0);
                }
            }
            // Emit a build event for each file format.
            for (let i = 0; i < options.format.length; i++) {
                const format = options.format[i];
                const esbuildOptions = (0, build_esbuild_options_1.buildEsbuildOptions)(format, options, context);
                const buildResult = yield tslib_1.__await(esbuild.build(esbuildOptions));
                if (options.metafile) {
                    const filename = options.format.length === 1
                        ? 'meta.json'
                        : `meta.${options.format[i]}.json`;
                    (0, fs_extra_1.writeJsonSync)((0, devkit_1.joinPathFragments)(options.outputPath, filename), buildResult.metafile);
                }
                yield yield tslib_1.__await({
                    success: buildResult.errors.length === 0,
                    // Need to call getOutfile directly in the case of bundle=false and outfile is not set for esbuild.
                    // This field is needed for `@nx/js:node` executor to work.
                    outfile: (0, path_1.join)(context.root, (0, build_esbuild_options_1.getOutfile)(format, options, context)),
                });
            }
        }
    });
}
exports.esbuildExecutor = esbuildExecutor;
function getTypeCheckOptions(options, context) {
    const { watch, tsConfig, outputPath } = options;
    const typeCheckOptions = {
        // TODO(jack): Add support for d.ts declaration files -- once the `@nx/js:tsc` changes are in we can use the same logic.
        mode: 'noEmit',
        tsConfigPath: tsConfig,
        // outDir: outputPath,
        workspaceRoot: context.root,
        rootDir: context.root,
    };
    if (watch) {
        typeCheckOptions.incremental = true;
        typeCheckOptions.cacheDir = devkit_1.cacheDir;
    }
    return typeCheckOptions;
}
function runTypeCheck(options, context) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { errors, warnings } = yield (0, js_1.runTypeCheck)(getTypeCheckOptions(options, context));
        const hasErrors = errors.length > 0;
        const hasWarnings = warnings.length > 0;
        if (hasErrors || hasWarnings) {
            yield (0, js_1.printDiagnostics)(errors, warnings);
        }
        return { errors, warnings };
    });
}
function registerCleanupCallback(callback) {
    const wrapped = () => {
        callback();
        process.off('SIGINT', wrapped);
        process.off('SIGTERM', wrapped);
        process.off('exit', wrapped);
    };
    process.on('SIGINT', wrapped);
    process.on('SIGTERM', wrapped);
    process.on('exit', wrapped);
}
exports.default = esbuildExecutor;
